{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"1","date":"2023-10-10T15:39:27.000Z","updated":"2023-10-10T15:41:52.996Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"数理统计大作业","date":"2023-10-12T07:12:56.418Z","updated":"2023-10-15T09:19:53.784Z","comments":true,"path":"2023/10/12/数理统计大作业/","link":"","permalink":"http://example.com/2023/10/12/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"第一次大作业 用Monte Carlo方法进行统计量分布和分位数计算 陈佳成 SY2342115 \\[ \\begin{equation} \\left\\{ \\begin{array}{lr} x=\\dfrac{3\\pi}{2}(1+2t)\\cos(\\dfrac{3\\pi}{2}(1+2t)), &amp; \\\\ y=s, &amp; 0 \\leq s \\leq L,|t| \\leq1. \\\\ z=\\dfrac{3\\pi}{2}(1+2t)\\sin(\\dfrac{3\\pi}{2}(1+2t)), &amp; \\end{array} \\right. \\end{equation} \\] （1）用Monte Carlo方法给出计算方法过程，输出计算结果 标准正态分布及参数为1的指数分布两种情况一样，先对样本进行采样，形成一个[try_num,sample_num]的矩阵，其中try_num表示试验的次数，sample_num表示样本容量。接着根据公式计算统计量，最后对try_num个统计量计算近似分布\\(P\\{T(z_1,z_2,...,z_n)\\leq t \\}\\)，画近似分布曲线以及对应的分位数\\(t_\\alpha\\) 当样本数=100，且重复做10000次时： 标准正态分布： 在α=0.01 ,0.05,0.1的情况下，满足\\(P\\{T(z_1,z_2,...,z_n)\\leq t_\\alpha \\}\\)的分位数分别为：0.2756、0.3093、0.3280 参数为1的指数分布： 在α=0.01 ,0.05,0.1的情况下，满足\\(P\\{T(z_1,z_2,...,z_n)\\leq t_\\alpha \\}\\)的分位数分别为：0.8081、0.8532、0.8801 （2） 讨论Monte Carlo方法计算结果随着样本容量变化时计算误差的变化，并进行总结。 首先讨论统计量的方差情况： 标准正态分布： \\[ \\begin{array}{|c|c|c|} \\hline sample\\_num / try\\_num &amp; 10 &amp; 100 &amp;1000&amp;10000\\\\ \\hline 10 &amp; 0.015363 &amp; 0.018968 &amp;0.018197&amp;0.018676\\\\ \\hline 100&amp;0.001623&amp;0.002800&amp; 0.003273&amp;0.003367\\\\ \\hline 1000&amp; 0.000995&amp; 0.000852&amp; 0.000966&amp;0.000979\\\\ \\hline 10000&amp;0.000093&amp;0.000350&amp;0.000406&amp;0.000378\\\\ \\hline \\end{array} \\] 参数为1的指数分布： \\[ \\begin{array}{|c|c|c|} \\hline sample\\_num / try\\_num &amp; 10 &amp; 100 &amp;1000&amp;10000\\\\ \\hline 10 &amp; 0.055294 &amp; 0.049272 &amp;0.050401&amp;0.052149\\\\ \\hline 100&amp;0.018492&amp;0.009244&amp; 0.009688&amp;0.009249\\\\ \\hline 1000&amp; 0.000621&amp; 0.001019 &amp;0.000998 &amp;0.000193\\\\ \\hline 10000&amp;0.000193 &amp; 0.000114 &amp; 0.000101 &amp; 0.000099 \\\\ \\hline \\end{array} \\] 可以看出来随着样本容量的增加，统计量的方差逐渐降低，说明统计量的整体精度在提升。 对于Monte Carlo方法，其误差\\(\\varepsilon=\\frac{\\lambda_\\alpha \\sigma}{\\sqrt{N}}\\)，其中均方差\\(\\sigma\\)未知，需用其估计值\\(\\hat{\\sigma=\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}X_i^2 -(\\frac{1}{N}\\sum_{i=1}^{N} X_i)^2}}\\) 代替，\\(\\lambda_\\alpha\\)与置信度\\(\\alpha\\)是一一对应，确定置信水平后，根据正态分布表，可确定出\\(\\lambda_\\alpha\\)： $$ \\[\\begin{array}{|c|c|c|} \\hline \\alpha &amp;0.01 &amp;0.05&amp;0.1\\\\ \\hline \\lambda_\\alpha &amp; 2.58 &amp; 1.96 &amp; 1.64\\\\ \\hline \\end{array}\\] $$ 根据该计算公式，可分别求出在不同置信度情况下的误差，以及随着样本容量变化时计算误差的变化，结果如下： $$ \\[\\begin{array}{|c|c|c|} \\hline \\alpha &amp;0.01 &amp;0.05&amp;0.1\\\\ \\hline \\varepsilon &amp; 0.00888 &amp; 0.00675 &amp; 0.00565\\\\ \\hline \\end{array}\\] $$ 当设定\\(\\alpha = 0.1,try\\_num= 10000\\) 时，观测误差随样本容量变化的规律: 在标准正态分布情况下： $$ \\[\\begin{array}{|c|c|c|} \\hline sample\\_num &amp;100 &amp;1000&amp;10000 &amp;30000\\\\ \\hline \\varepsilon &amp; 0.00888 &amp; 0.00161 &amp; 0.00063&amp;0.00043 \\\\ \\hline \\end{array}\\] \\[ 参数为1的指数分布： \\] \\[\\begin{array}{|c|c|c|} \\hline sample\\_num &amp;100 &amp;1000&amp;10000 &amp;30000\\\\ \\hline \\varepsilon &amp; 0.01458&amp; 0.00165 &amp; 0.00016 &amp;0.00005\\\\ \\hline \\end{array}\\] $$ 结论：结果随着样本容量变大，统计量\\(T(z_1,z_2,...,z_n)\\)的方差逐渐降低，且误差也逐渐降低。 代码附录： （1） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import numpy as npimport matplotlib.pyplot as pltclass Monte_Carlo(object): def __init__(self,sample_num,try_num): self.sample_num=sample_num self.try_num=try_num def standard_normal_distribution(self,t_alpha): z=np.random.normal(0,1,size=(self.try_num,self.sample_num)) z_mean=np.mean(z,axis=1).reshape(-1,1) ##[[z_mean1],[z_mean2],[z_mean3]...] z_min=np.min(z,axis=1).reshape(-1,1) ##[[z_min1],[z_min2],[z_min3]...] T=self.calculate(z,z_mean,z_min) print(&quot;var is :&#123;&#125;&quot;.format(np.var(T))) # self.draw(T) self.calculate_quantile(T,t_alpha) def exponential_distribution(self,parameter,t_alpha): z=np.random.exponential(parameter,size=(self.try_num,self.sample_num)) z_mean=np.mean(z,axis=1).reshape(-1,1) z_min=np.min(z,axis=1).reshape(-1,1) T=self.calculate(z,z_mean,z_min) print(&quot;var is :&#123;&#125;&quot;.format(np.var(T))) # self.draw(T) ##try_num*[z_mean,z_mean,z_mean] self.calculate_quantile(T,t_alpha) def calculate(self,z,z_mean,z_min): try: T=np.power(np.sum(np.power(z-z_mean,2),1)/self.sample_num,0.5).reshape(-1,1) /(z_mean-z_min)###[[T1],[T2],[T3]...] except ZeroDivisionError: T = 0 T=T.reshape(1,-1) ##[T1,T2,T3] return T def draw(self,T): count, bins_count = np.histogram(T,bins=100) pdf = count / sum(count) cdf = np.cumsum(pdf) plt.xlabel(&quot;t&quot;) plt.ylabel(&quot;P&quot;, rotation=&quot;horizontal&quot;) plt.plot(bins_count[1:], cdf, label=&quot;CDF&quot;) plt.show() def calculate_quantile(self,T,t_alpha): for i in t_alpha: print(&quot;alpha=&#123;&#125;,t_alpha=&#123;&#125;&quot;.format(i,np.percentile(T,i*100)))def analyse(combined_list,parameter,t_alpha): for [sample_num,try_num] in combined_list: print(&quot;sample_num=&#123;&#125;,try_num=&#123;&#125;:&quot;.format(sample_num,try_num)) monte_Carlo=Monte_Carlo(sample_num,try_num) print(&quot;standard_normal_distribution:&quot;) monte_Carlo.standard_normal_distribution(t_alpha) print(&quot;exponential_distribution:&quot;) monte_Carlo.exponential_distribution(parameter,t_alpha)def main(): sample_num=100 try_num=10000 parameter=1 t_alpha=[0,0.01,0.05,0.1,1] monte_Carlo=Monte_Carlo(sample_num,try_num) print(&quot;standard_normal_distribution:&quot;) monte_Carlo.standard_normal_distribution(t_alpha) print(&quot;exponential_distribution:&quot;) monte_Carlo.exponential_distribution(parameter,t_alpha) sample_num=[10,100,1000,10000] try_num=[10,100,1000,10000] parameter=1 t_alpha=[0.01,0.05,0.1,1] combined_list = [[x,y] for x in sample_num for y in try_num] analyse(combined_list,parameter,t_alpha) if __name__ == &quot;__main__&quot;: main() ​ （2) 123456squ_T=np.power(T,2) sigma_hat= np.mean(squ_T)- np.power(np.mean(T),2) lambda_alpha=[2.58,1.96,1.64] for i in range(3): sigma=lambda_alpha[i]*sigma_hat/(len(T)**0.5) print(&quot;alpha=&#123;&#125; sigma=&#123;&#125;&quot;.format(t_alpha[i],sigma))","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-10-10T13:31:50.872Z","updated":"2024-11-21T13:49:24.819Z","comments":true,"path":"2023/10/10/hello-world/","link":"","permalink":"http://example.com/2023/10/10/hello-world/","excerpt":"","text":"graph TD; A-->B; A-->C; B-->D; C-->D; Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}